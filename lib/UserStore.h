/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
#ifndef UserStore_H
#define UserStore_H

#include <TProcessor.h>
#include "UserStore_types.h"

namespace evernote { namespace edam {

class UserStoreIf {
 public:
  virtual ~UserStoreIf() {}
  virtual bool checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor) = 0;
  virtual void getBootstrapInfo(BootstrapInfo& _return, const std::string& locale) = 0;
  virtual void authenticate(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const bool supportsTwoFactor) = 0;
  virtual void authenticateLongSession(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor) = 0;
  virtual void completeTwoFactorAuthentication(AuthenticationResult& _return, const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription) = 0;
  virtual void revokeLongSession(const std::string& authenticationToken) = 0;
  virtual void authenticateToBusiness(AuthenticationResult& _return, const std::string& authenticationToken) = 0;
  virtual void refreshAuthentication(AuthenticationResult& _return, const std::string& authenticationToken) = 0;
  virtual void getUser(evernote::edam::User& _return, const std::string& authenticationToken) = 0;
  virtual void getPublicUserInfo(PublicUserInfo& _return, const std::string& username) = 0;
  virtual void getPremiumInfo(evernote::edam::PremiumInfo& _return, const std::string& authenticationToken) = 0;
  virtual void getNoteStoreUrl(std::string& _return, const std::string& authenticationToken) = 0;
};

class UserStoreNull : virtual public UserStoreIf {
 public:
  virtual ~UserStoreNull() {}
  bool checkVersion(const std::string& /* clientName */, const int16_t /* edamVersionMajor */, const int16_t /* edamVersionMinor */) {
    bool _return = false;
    return _return;
  }
  void getBootstrapInfo(BootstrapInfo& /* _return */, const std::string& /* locale */) {
    return;
  }
  void authenticate(AuthenticationResult& /* _return */, const std::string& /* username */, const std::string& /* password */, const std::string& /* consumerKey */, const std::string& /* consumerSecret */, const bool /* supportsTwoFactor */) {
    return;
  }
  void authenticateLongSession(AuthenticationResult& /* _return */, const std::string& /* username */, const std::string& /* password */, const std::string& /* consumerKey */, const std::string& /* consumerSecret */, const std::string& /* deviceIdentifier */, const std::string& /* deviceDescription */, const bool /* supportsTwoFactor */) {
    return;
  }
  void completeTwoFactorAuthentication(AuthenticationResult& /* _return */, const std::string& /* authenticationToken */, const std::string& /* oneTimeCode */, const std::string& /* deviceIdentifier */, const std::string& /* deviceDescription */) {
    return;
  }
  void revokeLongSession(const std::string& /* authenticationToken */) {
    return;
  }
  void authenticateToBusiness(AuthenticationResult& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void refreshAuthentication(AuthenticationResult& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getUser(evernote::edam::User& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getPublicUserInfo(PublicUserInfo& /* _return */, const std::string& /* username */) {
    return;
  }
  void getPremiumInfo(evernote::edam::PremiumInfo& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
  void getNoteStoreUrl(std::string& /* _return */, const std::string& /* authenticationToken */) {
    return;
  }
};

typedef struct _UserStore_checkVersion_args__isset {
  _UserStore_checkVersion_args__isset() : clientName(false), edamVersionMajor(false), edamVersionMinor(false) {}
  bool clientName;
  bool edamVersionMajor;
  bool edamVersionMinor;
} _UserStore_checkVersion_args__isset;

class UserStore_checkVersion_args {
 public:

  UserStore_checkVersion_args() : clientName(""), edamVersionMajor(1), edamVersionMinor(25) {
  }

  virtual ~UserStore_checkVersion_args() throw() {}

  std::string clientName;
  int16_t edamVersionMajor;
  int16_t edamVersionMinor;

  _UserStore_checkVersion_args__isset __isset;

  bool operator == (const UserStore_checkVersion_args & rhs) const
  {
    if (!(clientName == rhs.clientName))
      return false;
    if (!(edamVersionMajor == rhs.edamVersionMajor))
      return false;
    if (!(edamVersionMinor == rhs.edamVersionMinor))
      return false;
    return true;
  }
  bool operator != (const UserStore_checkVersion_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_checkVersion_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_checkVersion_pargs {
 public:


  virtual ~UserStore_checkVersion_pargs() throw() {}

  const std::string* clientName;
  const int16_t* edamVersionMajor;
  const int16_t* edamVersionMinor;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_checkVersion_result__isset {
  _UserStore_checkVersion_result__isset() : success(false) {}
  bool success;
} _UserStore_checkVersion_result__isset;

class UserStore_checkVersion_result {
 public:

  UserStore_checkVersion_result() : success(0) {
  }

  virtual ~UserStore_checkVersion_result() throw() {}

  bool success;

  _UserStore_checkVersion_result__isset __isset;

  bool operator == (const UserStore_checkVersion_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const UserStore_checkVersion_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_checkVersion_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_checkVersion_presult__isset {
  _UserStore_checkVersion_presult__isset() : success(false) {}
  bool success;
} _UserStore_checkVersion_presult__isset;

class UserStore_checkVersion_presult {
 public:


  virtual ~UserStore_checkVersion_presult() throw() {}

  bool* success;

  _UserStore_checkVersion_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getBootstrapInfo_args__isset {
  _UserStore_getBootstrapInfo_args__isset() : locale(false) {}
  bool locale;
} _UserStore_getBootstrapInfo_args__isset;

class UserStore_getBootstrapInfo_args {
 public:

  UserStore_getBootstrapInfo_args() : locale("") {
  }

  virtual ~UserStore_getBootstrapInfo_args() throw() {}

  std::string locale;

  _UserStore_getBootstrapInfo_args__isset __isset;

  bool operator == (const UserStore_getBootstrapInfo_args & rhs) const
  {
    if (!(locale == rhs.locale))
      return false;
    return true;
  }
  bool operator != (const UserStore_getBootstrapInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getBootstrapInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getBootstrapInfo_pargs {
 public:


  virtual ~UserStore_getBootstrapInfo_pargs() throw() {}

  const std::string* locale;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getBootstrapInfo_result__isset {
  _UserStore_getBootstrapInfo_result__isset() : success(false) {}
  bool success;
} _UserStore_getBootstrapInfo_result__isset;

class UserStore_getBootstrapInfo_result {
 public:

  UserStore_getBootstrapInfo_result() {
  }

  virtual ~UserStore_getBootstrapInfo_result() throw() {}

  BootstrapInfo success;

  _UserStore_getBootstrapInfo_result__isset __isset;

  bool operator == (const UserStore_getBootstrapInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const UserStore_getBootstrapInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getBootstrapInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getBootstrapInfo_presult__isset {
  _UserStore_getBootstrapInfo_presult__isset() : success(false) {}
  bool success;
} _UserStore_getBootstrapInfo_presult__isset;

class UserStore_getBootstrapInfo_presult {
 public:


  virtual ~UserStore_getBootstrapInfo_presult() throw() {}

  BootstrapInfo* success;

  _UserStore_getBootstrapInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_authenticate_args__isset {
  _UserStore_authenticate_args__isset() : username(false), password(false), consumerKey(false), consumerSecret(false), supportsTwoFactor(false) {}
  bool username;
  bool password;
  bool consumerKey;
  bool consumerSecret;
  bool supportsTwoFactor;
} _UserStore_authenticate_args__isset;

class UserStore_authenticate_args {
 public:

  UserStore_authenticate_args() : username(""), password(""), consumerKey(""), consumerSecret(""), supportsTwoFactor(0) {
  }

  virtual ~UserStore_authenticate_args() throw() {}

  std::string username;
  std::string password;
  std::string consumerKey;
  std::string consumerSecret;
  bool supportsTwoFactor;

  _UserStore_authenticate_args__isset __isset;

  bool operator == (const UserStore_authenticate_args & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(consumerKey == rhs.consumerKey))
      return false;
    if (!(consumerSecret == rhs.consumerSecret))
      return false;
    if (!(supportsTwoFactor == rhs.supportsTwoFactor))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_authenticate_pargs {
 public:


  virtual ~UserStore_authenticate_pargs() throw() {}

  const std::string* username;
  const std::string* password;
  const std::string* consumerKey;
  const std::string* consumerSecret;
  const bool* supportsTwoFactor;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticate_result__isset {
  _UserStore_authenticate_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_authenticate_result__isset;

class UserStore_authenticate_result {
 public:

  UserStore_authenticate_result() {
  }

  virtual ~UserStore_authenticate_result() throw() {}

  AuthenticationResult success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticate_result__isset __isset;

  bool operator == (const UserStore_authenticate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticate_presult__isset {
  _UserStore_authenticate_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_authenticate_presult__isset;

class UserStore_authenticate_presult {
 public:


  virtual ~UserStore_authenticate_presult() throw() {}

  AuthenticationResult* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_authenticateLongSession_args__isset {
  _UserStore_authenticateLongSession_args__isset() : username(false), password(false), consumerKey(false), consumerSecret(false), deviceIdentifier(false), deviceDescription(false), supportsTwoFactor(false) {}
  bool username;
  bool password;
  bool consumerKey;
  bool consumerSecret;
  bool deviceIdentifier;
  bool deviceDescription;
  bool supportsTwoFactor;
} _UserStore_authenticateLongSession_args__isset;

class UserStore_authenticateLongSession_args {
 public:

  UserStore_authenticateLongSession_args() : username(""), password(""), consumerKey(""), consumerSecret(""), deviceIdentifier(""), deviceDescription(""), supportsTwoFactor(0) {
  }

  virtual ~UserStore_authenticateLongSession_args() throw() {}

  std::string username;
  std::string password;
  std::string consumerKey;
  std::string consumerSecret;
  std::string deviceIdentifier;
  std::string deviceDescription;
  bool supportsTwoFactor;

  _UserStore_authenticateLongSession_args__isset __isset;

  bool operator == (const UserStore_authenticateLongSession_args & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(consumerKey == rhs.consumerKey))
      return false;
    if (!(consumerSecret == rhs.consumerSecret))
      return false;
    if (!(deviceIdentifier == rhs.deviceIdentifier))
      return false;
    if (!(deviceDescription == rhs.deviceDescription))
      return false;
    if (!(supportsTwoFactor == rhs.supportsTwoFactor))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateLongSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateLongSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_authenticateLongSession_pargs {
 public:


  virtual ~UserStore_authenticateLongSession_pargs() throw() {}

  const std::string* username;
  const std::string* password;
  const std::string* consumerKey;
  const std::string* consumerSecret;
  const std::string* deviceIdentifier;
  const std::string* deviceDescription;
  const bool* supportsTwoFactor;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateLongSession_result__isset {
  _UserStore_authenticateLongSession_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_authenticateLongSession_result__isset;

class UserStore_authenticateLongSession_result {
 public:

  UserStore_authenticateLongSession_result() {
  }

  virtual ~UserStore_authenticateLongSession_result() throw() {}

  AuthenticationResult success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateLongSession_result__isset __isset;

  bool operator == (const UserStore_authenticateLongSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateLongSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateLongSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateLongSession_presult__isset {
  _UserStore_authenticateLongSession_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_authenticateLongSession_presult__isset;

class UserStore_authenticateLongSession_presult {
 public:


  virtual ~UserStore_authenticateLongSession_presult() throw() {}

  AuthenticationResult* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateLongSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_completeTwoFactorAuthentication_args__isset {
  _UserStore_completeTwoFactorAuthentication_args__isset() : authenticationToken(false), oneTimeCode(false), deviceIdentifier(false), deviceDescription(false) {}
  bool authenticationToken;
  bool oneTimeCode;
  bool deviceIdentifier;
  bool deviceDescription;
} _UserStore_completeTwoFactorAuthentication_args__isset;

class UserStore_completeTwoFactorAuthentication_args {
 public:

  UserStore_completeTwoFactorAuthentication_args() : authenticationToken(""), oneTimeCode(""), deviceIdentifier(""), deviceDescription("") {
  }

  virtual ~UserStore_completeTwoFactorAuthentication_args() throw() {}

  std::string authenticationToken;
  std::string oneTimeCode;
  std::string deviceIdentifier;
  std::string deviceDescription;

  _UserStore_completeTwoFactorAuthentication_args__isset __isset;

  bool operator == (const UserStore_completeTwoFactorAuthentication_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    if (!(oneTimeCode == rhs.oneTimeCode))
      return false;
    if (!(deviceIdentifier == rhs.deviceIdentifier))
      return false;
    if (!(deviceDescription == rhs.deviceDescription))
      return false;
    return true;
  }
  bool operator != (const UserStore_completeTwoFactorAuthentication_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_completeTwoFactorAuthentication_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_completeTwoFactorAuthentication_pargs {
 public:


  virtual ~UserStore_completeTwoFactorAuthentication_pargs() throw() {}

  const std::string* authenticationToken;
  const std::string* oneTimeCode;
  const std::string* deviceIdentifier;
  const std::string* deviceDescription;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_completeTwoFactorAuthentication_result__isset {
  _UserStore_completeTwoFactorAuthentication_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_completeTwoFactorAuthentication_result__isset;

class UserStore_completeTwoFactorAuthentication_result {
 public:

  UserStore_completeTwoFactorAuthentication_result() {
  }

  virtual ~UserStore_completeTwoFactorAuthentication_result() throw() {}

  AuthenticationResult success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_completeTwoFactorAuthentication_result__isset __isset;

  bool operator == (const UserStore_completeTwoFactorAuthentication_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_completeTwoFactorAuthentication_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_completeTwoFactorAuthentication_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_completeTwoFactorAuthentication_presult__isset {
  _UserStore_completeTwoFactorAuthentication_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_completeTwoFactorAuthentication_presult__isset;

class UserStore_completeTwoFactorAuthentication_presult {
 public:


  virtual ~UserStore_completeTwoFactorAuthentication_presult() throw() {}

  AuthenticationResult* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_completeTwoFactorAuthentication_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_revokeLongSession_args__isset {
  _UserStore_revokeLongSession_args__isset() : authenticationToken(false) {}
  bool authenticationToken;
} _UserStore_revokeLongSession_args__isset;

class UserStore_revokeLongSession_args {
 public:

  UserStore_revokeLongSession_args() : authenticationToken("") {
  }

  virtual ~UserStore_revokeLongSession_args() throw() {}

  std::string authenticationToken;

  _UserStore_revokeLongSession_args__isset __isset;

  bool operator == (const UserStore_revokeLongSession_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_revokeLongSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_revokeLongSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_revokeLongSession_pargs {
 public:


  virtual ~UserStore_revokeLongSession_pargs() throw() {}

  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_revokeLongSession_result__isset {
  _UserStore_revokeLongSession_result__isset() : userException(false), systemException(false) {}
  bool userException;
  bool systemException;
} _UserStore_revokeLongSession_result__isset;

class UserStore_revokeLongSession_result {
 public:

  UserStore_revokeLongSession_result() {
  }

  virtual ~UserStore_revokeLongSession_result() throw() {}

  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_revokeLongSession_result__isset __isset;

  bool operator == (const UserStore_revokeLongSession_result & rhs) const
  {
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_revokeLongSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_revokeLongSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_revokeLongSession_presult__isset {
  _UserStore_revokeLongSession_presult__isset() : userException(false), systemException(false) {}
  bool userException;
  bool systemException;
} _UserStore_revokeLongSession_presult__isset;

class UserStore_revokeLongSession_presult {
 public:


  virtual ~UserStore_revokeLongSession_presult() throw() {}

  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_revokeLongSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_authenticateToBusiness_args__isset {
  _UserStore_authenticateToBusiness_args__isset() : authenticationToken(false) {}
  bool authenticationToken;
} _UserStore_authenticateToBusiness_args__isset;

class UserStore_authenticateToBusiness_args {
 public:

  UserStore_authenticateToBusiness_args() : authenticationToken("") {
  }

  virtual ~UserStore_authenticateToBusiness_args() throw() {}

  std::string authenticationToken;

  _UserStore_authenticateToBusiness_args__isset __isset;

  bool operator == (const UserStore_authenticateToBusiness_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateToBusiness_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateToBusiness_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_authenticateToBusiness_pargs {
 public:


  virtual ~UserStore_authenticateToBusiness_pargs() throw() {}

  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateToBusiness_result__isset {
  _UserStore_authenticateToBusiness_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_authenticateToBusiness_result__isset;

class UserStore_authenticateToBusiness_result {
 public:

  UserStore_authenticateToBusiness_result() {
  }

  virtual ~UserStore_authenticateToBusiness_result() throw() {}

  AuthenticationResult success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateToBusiness_result__isset __isset;

  bool operator == (const UserStore_authenticateToBusiness_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_authenticateToBusiness_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_authenticateToBusiness_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_authenticateToBusiness_presult__isset {
  _UserStore_authenticateToBusiness_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_authenticateToBusiness_presult__isset;

class UserStore_authenticateToBusiness_presult {
 public:


  virtual ~UserStore_authenticateToBusiness_presult() throw() {}

  AuthenticationResult* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_authenticateToBusiness_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_refreshAuthentication_args__isset {
  _UserStore_refreshAuthentication_args__isset() : authenticationToken(false) {}
  bool authenticationToken;
} _UserStore_refreshAuthentication_args__isset;

class UserStore_refreshAuthentication_args {
 public:

  UserStore_refreshAuthentication_args() : authenticationToken("") {
  }

  virtual ~UserStore_refreshAuthentication_args() throw() {}

  std::string authenticationToken;

  _UserStore_refreshAuthentication_args__isset __isset;

  bool operator == (const UserStore_refreshAuthentication_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_refreshAuthentication_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_refreshAuthentication_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_refreshAuthentication_pargs {
 public:


  virtual ~UserStore_refreshAuthentication_pargs() throw() {}

  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_refreshAuthentication_result__isset {
  _UserStore_refreshAuthentication_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_refreshAuthentication_result__isset;

class UserStore_refreshAuthentication_result {
 public:

  UserStore_refreshAuthentication_result() {
  }

  virtual ~UserStore_refreshAuthentication_result() throw() {}

  AuthenticationResult success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_refreshAuthentication_result__isset __isset;

  bool operator == (const UserStore_refreshAuthentication_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_refreshAuthentication_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_refreshAuthentication_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_refreshAuthentication_presult__isset {
  _UserStore_refreshAuthentication_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_refreshAuthentication_presult__isset;

class UserStore_refreshAuthentication_presult {
 public:


  virtual ~UserStore_refreshAuthentication_presult() throw() {}

  AuthenticationResult* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_refreshAuthentication_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getUser_args__isset {
  _UserStore_getUser_args__isset() : authenticationToken(false) {}
  bool authenticationToken;
} _UserStore_getUser_args__isset;

class UserStore_getUser_args {
 public:

  UserStore_getUser_args() : authenticationToken("") {
  }

  virtual ~UserStore_getUser_args() throw() {}

  std::string authenticationToken;

  _UserStore_getUser_args__isset __isset;

  bool operator == (const UserStore_getUser_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_getUser_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getUser_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getUser_pargs {
 public:


  virtual ~UserStore_getUser_pargs() throw() {}

  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getUser_result__isset {
  _UserStore_getUser_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_getUser_result__isset;

class UserStore_getUser_result {
 public:

  UserStore_getUser_result() {
  }

  virtual ~UserStore_getUser_result() throw() {}

  evernote::edam::User success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_getUser_result__isset __isset;

  bool operator == (const UserStore_getUser_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getUser_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getUser_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getUser_presult__isset {
  _UserStore_getUser_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_getUser_presult__isset;

class UserStore_getUser_presult {
 public:


  virtual ~UserStore_getUser_presult() throw() {}

  evernote::edam::User* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_getUser_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getPublicUserInfo_args__isset {
  _UserStore_getPublicUserInfo_args__isset() : username(false) {}
  bool username;
} _UserStore_getPublicUserInfo_args__isset;

class UserStore_getPublicUserInfo_args {
 public:

  UserStore_getPublicUserInfo_args() : username("") {
  }

  virtual ~UserStore_getPublicUserInfo_args() throw() {}

  std::string username;

  _UserStore_getPublicUserInfo_args__isset __isset;

  bool operator == (const UserStore_getPublicUserInfo_args & rhs) const
  {
    if (!(username == rhs.username))
      return false;
    return true;
  }
  bool operator != (const UserStore_getPublicUserInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getPublicUserInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getPublicUserInfo_pargs {
 public:


  virtual ~UserStore_getPublicUserInfo_pargs() throw() {}

  const std::string* username;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getPublicUserInfo_result__isset {
  _UserStore_getPublicUserInfo_result__isset() : success(false), notFoundException(false), systemException(false), userException(false) {}
  bool success;
  bool notFoundException;
  bool systemException;
  bool userException;
} _UserStore_getPublicUserInfo_result__isset;

class UserStore_getPublicUserInfo_result {
 public:

  UserStore_getPublicUserInfo_result() {
  }

  virtual ~UserStore_getPublicUserInfo_result() throw() {}

  PublicUserInfo success;
  evernote::edam::EDAMNotFoundException notFoundException;
  evernote::edam::EDAMSystemException systemException;
  evernote::edam::EDAMUserException userException;

  _UserStore_getPublicUserInfo_result__isset __isset;

  bool operator == (const UserStore_getPublicUserInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(notFoundException == rhs.notFoundException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    if (!(userException == rhs.userException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getPublicUserInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getPublicUserInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getPublicUserInfo_presult__isset {
  _UserStore_getPublicUserInfo_presult__isset() : success(false), notFoundException(false), systemException(false), userException(false) {}
  bool success;
  bool notFoundException;
  bool systemException;
  bool userException;
} _UserStore_getPublicUserInfo_presult__isset;

class UserStore_getPublicUserInfo_presult {
 public:


  virtual ~UserStore_getPublicUserInfo_presult() throw() {}

  PublicUserInfo* success;
  evernote::edam::EDAMNotFoundException notFoundException;
  evernote::edam::EDAMSystemException systemException;
  evernote::edam::EDAMUserException userException;

  _UserStore_getPublicUserInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getPremiumInfo_args__isset {
  _UserStore_getPremiumInfo_args__isset() : authenticationToken(false) {}
  bool authenticationToken;
} _UserStore_getPremiumInfo_args__isset;

class UserStore_getPremiumInfo_args {
 public:

  UserStore_getPremiumInfo_args() : authenticationToken("") {
  }

  virtual ~UserStore_getPremiumInfo_args() throw() {}

  std::string authenticationToken;

  _UserStore_getPremiumInfo_args__isset __isset;

  bool operator == (const UserStore_getPremiumInfo_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_getPremiumInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getPremiumInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getPremiumInfo_pargs {
 public:


  virtual ~UserStore_getPremiumInfo_pargs() throw() {}

  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getPremiumInfo_result__isset {
  _UserStore_getPremiumInfo_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_getPremiumInfo_result__isset;

class UserStore_getPremiumInfo_result {
 public:

  UserStore_getPremiumInfo_result() {
  }

  virtual ~UserStore_getPremiumInfo_result() throw() {}

  evernote::edam::PremiumInfo success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_getPremiumInfo_result__isset __isset;

  bool operator == (const UserStore_getPremiumInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getPremiumInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getPremiumInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getPremiumInfo_presult__isset {
  _UserStore_getPremiumInfo_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_getPremiumInfo_presult__isset;

class UserStore_getPremiumInfo_presult {
 public:


  virtual ~UserStore_getPremiumInfo_presult() throw() {}

  evernote::edam::PremiumInfo* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_getPremiumInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _UserStore_getNoteStoreUrl_args__isset {
  _UserStore_getNoteStoreUrl_args__isset() : authenticationToken(false) {}
  bool authenticationToken;
} _UserStore_getNoteStoreUrl_args__isset;

class UserStore_getNoteStoreUrl_args {
 public:

  UserStore_getNoteStoreUrl_args() : authenticationToken("") {
  }

  virtual ~UserStore_getNoteStoreUrl_args() throw() {}

  std::string authenticationToken;

  _UserStore_getNoteStoreUrl_args__isset __isset;

  bool operator == (const UserStore_getNoteStoreUrl_args & rhs) const
  {
    if (!(authenticationToken == rhs.authenticationToken))
      return false;
    return true;
  }
  bool operator != (const UserStore_getNoteStoreUrl_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getNoteStoreUrl_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class UserStore_getNoteStoreUrl_pargs {
 public:


  virtual ~UserStore_getNoteStoreUrl_pargs() throw() {}

  const std::string* authenticationToken;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getNoteStoreUrl_result__isset {
  _UserStore_getNoteStoreUrl_result__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_getNoteStoreUrl_result__isset;

class UserStore_getNoteStoreUrl_result {
 public:

  UserStore_getNoteStoreUrl_result() : success("") {
  }

  virtual ~UserStore_getNoteStoreUrl_result() throw() {}

  std::string success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_getNoteStoreUrl_result__isset __isset;

  bool operator == (const UserStore_getNoteStoreUrl_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(userException == rhs.userException))
      return false;
    if (!(systemException == rhs.systemException))
      return false;
    return true;
  }
  bool operator != (const UserStore_getNoteStoreUrl_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UserStore_getNoteStoreUrl_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _UserStore_getNoteStoreUrl_presult__isset {
  _UserStore_getNoteStoreUrl_presult__isset() : success(false), userException(false), systemException(false) {}
  bool success;
  bool userException;
  bool systemException;
} _UserStore_getNoteStoreUrl_presult__isset;

class UserStore_getNoteStoreUrl_presult {
 public:


  virtual ~UserStore_getNoteStoreUrl_presult() throw() {}

  std::string* success;
  evernote::edam::EDAMUserException userException;
  evernote::edam::EDAMSystemException systemException;

  _UserStore_getNoteStoreUrl_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class UserStoreClient : virtual public UserStoreIf {
 public:
  UserStoreClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  UserStoreClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor);
  void send_checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor);
  bool recv_checkVersion();
  void getBootstrapInfo(BootstrapInfo& _return, const std::string& locale);
  void send_getBootstrapInfo(const std::string& locale);
  void recv_getBootstrapInfo(BootstrapInfo& _return);
  void authenticate(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const bool supportsTwoFactor);
  void send_authenticate(const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const bool supportsTwoFactor);
  void recv_authenticate(AuthenticationResult& _return);
  void authenticateLongSession(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor);
  void send_authenticateLongSession(const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor);
  void recv_authenticateLongSession(AuthenticationResult& _return);
  void completeTwoFactorAuthentication(AuthenticationResult& _return, const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription);
  void send_completeTwoFactorAuthentication(const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription);
  void recv_completeTwoFactorAuthentication(AuthenticationResult& _return);
  void revokeLongSession(const std::string& authenticationToken);
  void send_revokeLongSession(const std::string& authenticationToken);
  void recv_revokeLongSession();
  void authenticateToBusiness(AuthenticationResult& _return, const std::string& authenticationToken);
  void send_authenticateToBusiness(const std::string& authenticationToken);
  void recv_authenticateToBusiness(AuthenticationResult& _return);
  void refreshAuthentication(AuthenticationResult& _return, const std::string& authenticationToken);
  void send_refreshAuthentication(const std::string& authenticationToken);
  void recv_refreshAuthentication(AuthenticationResult& _return);
  void getUser(evernote::edam::User& _return, const std::string& authenticationToken);
  void send_getUser(const std::string& authenticationToken);
  void recv_getUser(evernote::edam::User& _return);
  void getPublicUserInfo(PublicUserInfo& _return, const std::string& username);
  void send_getPublicUserInfo(const std::string& username);
  void recv_getPublicUserInfo(PublicUserInfo& _return);
  void getPremiumInfo(evernote::edam::PremiumInfo& _return, const std::string& authenticationToken);
  void send_getPremiumInfo(const std::string& authenticationToken);
  void recv_getPremiumInfo(evernote::edam::PremiumInfo& _return);
  void getNoteStoreUrl(std::string& _return, const std::string& authenticationToken);
  void send_getNoteStoreUrl(const std::string& authenticationToken);
  void recv_getNoteStoreUrl(std::string& _return);
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class UserStoreProcessor : virtual public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<UserStoreIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid);
 private:
  std::map<std::string, void (UserStoreProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*)> processMap_;
  void process_checkVersion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getBootstrapInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_authenticate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_authenticateLongSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_completeTwoFactorAuthentication(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_revokeLongSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_authenticateToBusiness(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_refreshAuthentication(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getUser(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getPublicUserInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getPremiumInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
  void process_getNoteStoreUrl(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot);
 public:
  UserStoreProcessor(boost::shared_ptr<UserStoreIf> iface) :
    iface_(iface) {
    processMap_["checkVersion"] = &UserStoreProcessor::process_checkVersion;
    processMap_["getBootstrapInfo"] = &UserStoreProcessor::process_getBootstrapInfo;
    processMap_["authenticate"] = &UserStoreProcessor::process_authenticate;
    processMap_["authenticateLongSession"] = &UserStoreProcessor::process_authenticateLongSession;
    processMap_["completeTwoFactorAuthentication"] = &UserStoreProcessor::process_completeTwoFactorAuthentication;
    processMap_["revokeLongSession"] = &UserStoreProcessor::process_revokeLongSession;
    processMap_["authenticateToBusiness"] = &UserStoreProcessor::process_authenticateToBusiness;
    processMap_["refreshAuthentication"] = &UserStoreProcessor::process_refreshAuthentication;
    processMap_["getUser"] = &UserStoreProcessor::process_getUser;
    processMap_["getPublicUserInfo"] = &UserStoreProcessor::process_getPublicUserInfo;
    processMap_["getPremiumInfo"] = &UserStoreProcessor::process_getPremiumInfo;
    processMap_["getNoteStoreUrl"] = &UserStoreProcessor::process_getNoteStoreUrl;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot);
  virtual ~UserStoreProcessor() {}
};

class UserStoreMultiface : virtual public UserStoreIf {
 public:
  UserStoreMultiface(std::vector<boost::shared_ptr<UserStoreIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~UserStoreMultiface() {}
 protected:
  std::vector<boost::shared_ptr<UserStoreIf> > ifaces_;
  UserStoreMultiface() {}
  void add(boost::shared_ptr<UserStoreIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  bool checkVersion(const std::string& clientName, const int16_t edamVersionMajor, const int16_t edamVersionMinor) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->checkVersion(clientName, edamVersionMajor, edamVersionMinor);
      } else {
        ifaces_[i]->checkVersion(clientName, edamVersionMajor, edamVersionMinor);
      }
    }
  }

  void getBootstrapInfo(BootstrapInfo& _return, const std::string& locale) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getBootstrapInfo(_return, locale);
        return;
      } else {
        ifaces_[i]->getBootstrapInfo(_return, locale);
      }
    }
  }

  void authenticate(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const bool supportsTwoFactor) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->authenticate(_return, username, password, consumerKey, consumerSecret, supportsTwoFactor);
        return;
      } else {
        ifaces_[i]->authenticate(_return, username, password, consumerKey, consumerSecret, supportsTwoFactor);
      }
    }
  }

  void authenticateLongSession(AuthenticationResult& _return, const std::string& username, const std::string& password, const std::string& consumerKey, const std::string& consumerSecret, const std::string& deviceIdentifier, const std::string& deviceDescription, const bool supportsTwoFactor) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->authenticateLongSession(_return, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor);
        return;
      } else {
        ifaces_[i]->authenticateLongSession(_return, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor);
      }
    }
  }

  void completeTwoFactorAuthentication(AuthenticationResult& _return, const std::string& authenticationToken, const std::string& oneTimeCode, const std::string& deviceIdentifier, const std::string& deviceDescription) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->completeTwoFactorAuthentication(_return, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription);
        return;
      } else {
        ifaces_[i]->completeTwoFactorAuthentication(_return, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription);
      }
    }
  }

  void revokeLongSession(const std::string& authenticationToken) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      ifaces_[i]->revokeLongSession(authenticationToken);
    }
  }

  void authenticateToBusiness(AuthenticationResult& _return, const std::string& authenticationToken) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->authenticateToBusiness(_return, authenticationToken);
        return;
      } else {
        ifaces_[i]->authenticateToBusiness(_return, authenticationToken);
      }
    }
  }

  void refreshAuthentication(AuthenticationResult& _return, const std::string& authenticationToken) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->refreshAuthentication(_return, authenticationToken);
        return;
      } else {
        ifaces_[i]->refreshAuthentication(_return, authenticationToken);
      }
    }
  }

  void getUser(evernote::edam::User& _return, const std::string& authenticationToken) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getUser(_return, authenticationToken);
        return;
      } else {
        ifaces_[i]->getUser(_return, authenticationToken);
      }
    }
  }

  void getPublicUserInfo(PublicUserInfo& _return, const std::string& username) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getPublicUserInfo(_return, username);
        return;
      } else {
        ifaces_[i]->getPublicUserInfo(_return, username);
      }
    }
  }

  void getPremiumInfo(evernote::edam::PremiumInfo& _return, const std::string& authenticationToken) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getPremiumInfo(_return, authenticationToken);
        return;
      } else {
        ifaces_[i]->getPremiumInfo(_return, authenticationToken);
      }
    }
  }

  void getNoteStoreUrl(std::string& _return, const std::string& authenticationToken) {
    uint32_t sz = ifaces_.size();
    for (uint32_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->getNoteStoreUrl(_return, authenticationToken);
        return;
      } else {
        ifaces_[i]->getNoteStoreUrl(_return, authenticationToken);
      }
    }
  }

};

}} // namespace

#endif
